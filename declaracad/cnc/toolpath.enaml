"""
Copyright (c) 2020, Jairus Martin.

Distributed under the terms of the GPL v3 License.

The full license is in the file LICENSE, distributed with this software.

Created on Aug 22, 2020

@author: jrm
"""
import sys
import time
from atom.api import Atom, Bool, List
from declaracad.occ.api import Part, Polyline, Topology, Point, Looper
from declaracad.core.utils import log
from declaracad.cnc.gcode import Movement, save_to_file

from OCCT.BRepAdaptor import BRepAdaptor_CompCurve



def optimize_toolpath(wires, start_point, optimizer_timeout=30):
    """  Use Dijkstra's algorithm to find the shortest path between
    a set of wires. Ported from Inkcut

    Parameters
    ----------
    wires: List[TopoDS_Wire]
        Unordered set of wires
    start_point: Point
        Starting point

    Returns
    -------
    wires: List[TopoDS_Wires]
        Wires in the optimal move order

    """
    if len(wires) < 2:
        return wires
    now = time.time()
    time_limit = now + optimizer_timeout

    original = wires[:]
    subpaths = [BRepAdaptor_CompCurve(w) for w in wires]
    result = []
    sp = subpaths[0]
    p = start_point.proxy
    while subpaths:
        best = sys.maxsize
        shortest = None
        for sp in subpaths:
            start_point = sp.Value(sp.FirstParameter())
            d = p.Distance(start_point)
            if d < best:
                best = d
                shortest = sp

        p = shortest.Value(shortest.LastParameter())
        result.append(shortest)
        subpaths.remove(shortest)

        # time.time() is slow so limit the calls
        if time.time() > time_limit:
            result.extend(subpaths)  # At least part of it is optimized
            log.warning(
                "Shortest path search aborted (time limit reached)")
            break

    duration = time.time() - now

    return [sp.Wire() for sp in result]


def send_it(path, sleep=0.3):
    with open(path) as f:
        lines = f.read().split("\n")
    s.write(b'IN\n')
    s.write(b'SE\n')

    for line in lines:
        time.sleep(0.1)
        print(line)
        s.write(line.encode() + b'\n')
    s.write(b'SD\n')


enamldef Toolpath(Part): toolpath:
    #: List of wires to create the toolpath for
    attr wires: list = []

    #: Distance the head must lift when moving
    attr clearance = 3

    #: Max deflection when discretizing the curves
    attr deflection = 0.01

    #: Start point
    attr start_point = Point(0, 0, clearance)

    #: End point
    attr end_point << start_point

    #: Optimize order of movements
    attr optimize: bool = True

    #: List of movements
    attr movements << generate_toolpath(wires)

    #: Update description that shows up in the UI
    #: when the movements are updated and the bbox changes
    description << format_description(self.bbox, self.movements)

    #: Path colors
    attr move_color: str = "green"
    attr cut_color: str = "red"

    #: If set, write to filename
    attr filename: str = ""
    attr options: dict = {}

    func generate_toolpath(wires):
        """ A very simple toolpath generator

        """
        if self.optimize:
            wires = optimize_toolpath(wires, start_point)
        pos = start_point
        cmds = []
        lift = (0, 0, self.clearance)
        for i, wire in enumerate(wires):
            points = Topology.discretize(wire, self.deflection)
            next_point = points[0]
            cmds.append(Movement(
                rapid=True,
                points=[
                    pos,
                    pos + lift  if i > 0 else pos,
                    next_point + lift,
                    next_point,
                ]
            ))

            cmds.append(Movement(rapid=False, points=points))
            pos = points[-1]

        # Add move to home
        cmds.append(Movement(rapid=True, points=[pos, pos + lift,  end_point]))

        # Save
        if self.filename:
            save_to_file(self.filename, cmds, **self.options)

        return cmds

    func get_path_color(movement):
        """ Get a color for the movement """
        return self.move_color if movement.rapid else self.cut_color

    func format_description(*args):
        """ Toolpath description

        """
        n = len(self.movements)
        bbox = self.bbox
        l = 0
        last = start_point
        for m in movements:
            for p in m.points:
                l += last.distance(p)

        return "    \n".join([
            f"Moves: {n}",
            f"Path Length: {l}",
            f"Area: {bbox.dx} x {bbox.dy} x {bbox.dx}",
        ])

    func format_move_description(movement):
        l = 0
        last = movement.points[0]
        for p in movement.points[1:]:
            l += last.distance(p)
        return f'Length: {l}'

    Looper:
        iterable << toolpath.movements
        Polyline:
            attr movement = loop.item
            name = 'Rapid Move' if movement.rapid else 'Move'
            description = format_move_description(movement)
            transparency = 0.5
            color = get_path_color(movement)
            points = movement.points
