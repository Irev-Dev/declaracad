"""
Copyright (c) 2020, Jairus Martin.

Distributed under the terms of the GPL v3 License.

The full license is in the file LICENSE, distributed with this software.

Created on Aug 22, 2020

@author: jrm
"""
import sys
import time
from atom.api import Atom, Bool, List
from declaracad.occ.api import Part, Polyline, Topology, Point, Looper
from declaracad.core.utils import log

from OCCT.BRepAdaptor import BRepAdaptor_CompCurve


class Movement(Atom):
    rapid = Bool()
    points = List()

    def clone(self):
        return Movement(
            rapid=self.rapid,
            points=[Point(*p) for p in self.points])


def optimize_toolpath(wires, start_point, optimizer_timeout=30):
    """  Use Dijkstra's algorithm to find the shortest path between
    a set of wires. Ported from Inkcut

    Parameters
    ----------
    wires: List[TopoDS_Wire]
        Unordered set of wires
    start_point: Point
        Starting point

    Returns
    -------
    wires: List[TopoDS_Wires]
        Wires in the optimal move order

    """
    if len(wires) < 2:
        return wires
    now = time.time()
    time_limit = now + optimizer_timeout

    original = wires[:]
    subpaths = [BRepAdaptor_CompCurve(w) for w in wires]
    result = []
    sp = subpaths[0]
    p = start_point.proxy
    while subpaths:
        best = sys.maxsize
        shortest = None
        for sp in subpaths:
            start_point = sp.Value(sp.FirstParameter())
            d = p.Distance(start_point)
            if d < best:
                best = d
                shortest = sp

        p = shortest.Value(shortest.LastParameter())
        result.append(shortest)
        subpaths.remove(shortest)

        # time.time() is slow so limit the calls
        if time.time() > time_limit:
            result.extend(subpaths)  # At least part of it is optimized
            log.warning(
                "Shortest path search aborted (time limit reached)")
            break

    duration = time.time() - now

    return [sp.Wire() for sp in result]


def save_to_file(filename, movements, precision=3, offset=None, scale=1,
                 mirror_z=False, swap_xy=False):
    """ Write to a file

    Parameters
    ----------
    filename: String
        The path to the file to save
    movements: List[Movement]
        List of movements to save
    offset: Point or None
        If given it will be added to each point
    scale: Float
        If given, each point will be multiplied by the scale
    precision: Int or None
        Number of decimal places to use. If 0 converts to an integer,
        if None use full precision
    mirror_z: Bool
        Mirror z axis about the center
    swap_xy: Bool
        Swap xy coordinates
    """
    # Lambda for converting points
    if precision == 0:
        convert = lambda v: int(v*scale)
    elif precision is None:
        convert = lambda v: v*scale
    else:
        convert = lambda v: round(v*scale, precision)

    # Use a copy since we modify them
    movements = [m.clone() for m in movements]

    maxs = Point(0, 0, 0)
    mins = Point(0, 0, 0)
    for movement in movements:
        for i, p in enumerate(movement.points):
            if offset is not None:
                p = movement.points[i] = p + offset
            maxs.x = max(maxs.x, p.x)
            maxs.y = max(maxs.y, p.y)
            maxs.z = max(maxs.z, p.z)

            mins.x = min(mins.x, p.x)
            mins.y = min(mins.y, p.y)
            mins.z = min(mins.z, p.z)

    if mirror_z:
        top = maxs.z
        for movement in movements:
            for i, p in enumerate(movement.points):
                movement.points[i] = Point(p.x, p.y, top - p.z)

    with open(filename, 'w') as f:
        f.write("(Generated by DeclaraCAD)\n")
        f.write(f"(Path: {filename})\n")
        for movement in movements:
            cmd = "G0" if movement.rapid else "G1"
            for p in movement.points:
                x, y, z = map(convert, p)
                if swap_xy:
                    x, y = y, x
                f.write(f"{cmd} X{x} Y{y} Z{z}\n")


def send_it(path, sleep=0.3):
    with open(path) as f:
        lines = f.read().split("\n")
    s.write(b'IN\n')
    s.write(b'SE\n')

    for line in lines:
        time.sleep(0.1)
        print(line)
        s.write(line.encode() + b'\n')
    s.write(b'SD\n')


enamldef Toolpath(Part): toolpath:
    #: List of wires to create the toolpath for
    attr wires: list = []

    #: Distance the head must lift when moving
    attr clearance = 3

    #: Max deflection when discretizing the curves
    attr deflection = 0.01

    #: Start point
    attr start_point = Point(0, 0, clearance)

    #: End point
    attr end_point << start_point

    #: Optimize order of movements
    attr optimize: bool = True

    #: List of movements
    attr movements << generate_toolpath(wires)

    #: Update description that shows up in the UI
    #: when the movements are updated and the bbox changes
    description << format_description(self.bbox, self.movements)

    #: Path colors
    attr move_color: str = "green"
    attr cut_color: str = "red"

    #: If set, write to filename
    attr filename: str = ""
    attr options: dict = {}

    func generate_toolpath(wires):
        """ A very simple toolpath generator

        """
        if self.optimize:
            wires = optimize_toolpath(wires, start_point)
        pos = start_point
        cmds = []
        lift = (0, 0, self.clearance)
        for i, wire in enumerate(wires):
            points = Topology.discretize(wire, self.deflection)
            next_point = points[0]
            cmds.append(Movement(
                rapid=True,
                points=[
                    pos,
                    pos + lift  if i > 0 else pos,
                    next_point + lift,
                    next_point,
                ]
            ))

            cmds.append(Movement(rapid=False, points=points))
            pos = points[-1]

        # Add move to home
        cmds.append(Movement(rapid=True, points=[pos, pos + lift,  end_point]))

        # Save
        if self.filename:
            save_to_file(self.filename, cmds, **self.options)

        return cmds

    func get_path_color(movement):
        """ Get a color for the movement """
        return self.move_color if movement.rapid else self.cut_color

    func format_description(*args):
        """ Toolpath description

        """
        n = len(self.movements)
        bbox = self.bbox
        l = 0
        last = start_point
        for m in movements:
            for p in m.points:
                l += last.distance(p)

        return "    \n".join([
            f"Moves: {n}",
            f"Path Length: {l}",
            f"Area: {bbox.dx} x {bbox.dy} x {bbox.dx}",
        ])

    func format_move_description(movement):
        l = 0
        last = movement.points[0]
        for p in movement.points[1:]:
            l += last.distance(p)
        return f'Length: {l}'


    Looper:
        iterable << toolpath.movements
        Polyline:
            attr movement = loop.item
            name = 'Rapid Move' if movement.rapid else 'Move'
            description = format_move_description(movement)
            transparency = 0.5
            color = get_path_color(movement)
            points = movement.points
